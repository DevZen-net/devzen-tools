import * as _ from 'lodash'
import * as z from '@neozen/zen'
import { arrayize, isRealObject, type } from '@neozen/zen'
import {
  isArray,
  isBoolean,
  isBooleanString,
  isInt,
  isNumber,
  isNumberString,
  isString,
  isHash,
  isAlpha,
  isAscii,
  isBIC,
  isAlphanumeric,
  isBase32,
  isBase58,
  isBase64,
  isEAN,
  isEmail,
  isFQDN,
  isBtcAddress,
  isIBAN,
  isHSL,
  isCreditCard,
  isDefined,
  isDataURI,
  isDateString,
  isEthereumAddress,
  isFirebasePushId,
  isHexadecimal,
  isHexColor,
  isFullWidth,
  isHalfWidth,
  isISIN,
  isISO4217CurrencyCode,
  isISO31661Alpha2,
  isISO31661Alpha3,
  isISRC,
  isJSON,
  isJWT,
  isLatitude,
  isLowercase,
  isLocale,
  isLatLong,
  isLongitude,
  isMagnetURI,
  isMilitaryTime,
  isMimeType,
  isMongoId,
  isMACAddress,
  isMultibyte,
  isNegative,
  isOctal,
  isPositive,
  isPort,
  isRFC3339,
  isSemVer,
  isRgbColor,
  isTimeZone,
  isSurrogatePair,
  isVariableWidth,
  isUUID,
  isISBN,
  isDate,
  // eslint-disable-next-line import/named
  ValidationArguments,
  ValidationError,
} from 'class-validator'
import { isAwsARN, isAwsRegion, isDayjs, isDuration } from 'class-validator-extended'

// local
import { ValidZenValidationError } from './types'
import { internalNodeUtilInspect } from './utils/internalNodeUtilInspect'
import { getTinyLog } from './utils/tiny-log'

import { ValidateByAsValidatorFunction } from './wrap/ValidateByAsValidatorFunction'
import {
  ValidationOptionsWrapped,
  wrapPropertyDecoratorUsingValidateBy,
} from './wrap/wrapPropertyDecoratorUsingValidateBy'

const _log = getTinyLog(false, 'OrAnd')
/*
Generated by
.split(',\n').map(s => {
  let name = s.slice(2)
  if (_.toUpper(name[1]) !== name[1])
    name = _.toLower(name[0]) + name.slice(1)
  return `${name}: ${s},`
})
 */
export const validZenTypesConformityValidators = {
  BIC: isBIC,
  EAN: isEAN,
  FQDN: isFQDN,
  HSL: isHSL,
  IBAN: isIBAN,
  ISBN10: (v) => isISBN(v, 10),
  ISBN13: (v) => isISBN(v, 13),
  ISBN: (v) => isISBN(v, 10) || isISBN(v, 13),
  ISIN: isISIN,
  ISO31661Alpha2: isISO31661Alpha2,
  ISO31661Alpha3: isISO31661Alpha3,
  ISO4217CurrencyCode: isISO4217CurrencyCode,
  ISRC: isISRC,
  JSON: isJSON,
  JWT: isJWT,
  MACAddress: (v) => isMACAddress(v) || isMACAddress(v, {no_colons: true}),
  MACAddressStrict: isMACAddress,
  RFC3339: isRFC3339,
  UUID3: (v) => isUUID(v, 3),
  UUID4: (v) => isUUID(v, 4),
  UUID5: (v) => isUUID(v, 5),
  UUID: (v) => isUUID(v, 'all'),
  alpha: isAlpha,
  alphanumeric: isAlphanumeric,
  arguments: _.isArguments,
  array: isArray,
  ascii: isAscii,
  awsARN: isAwsARN,
  awsRegion: isAwsRegion,
  base32: isBase32,
  base58: isBase58,
  base64: isBase64,
  bigint: z.isBigInt,
  boolean: isBoolean,
  booleanString: isBooleanString,
  btcAddress: isBtcAddress,
  buffer: _.isBuffer,
  creditCard: isCreditCard,
  dataURI: isDataURI,
  date: isDate,
  dateString: isDateString,
  dayjs: isDayjs,
  decimal: (v: any) => isNumber(v) && !isInt(v) && !z.isBigInt(v),
  defined: isDefined,
  duration: isDuration,
  element: _.isElement,
  email: isEmail,
  empty: _.isEmpty as (any) => boolean,
  error: _.isError,
  ethereumAddress: isEthereumAddress,
  false: z.isFalse,
  finite: _.isFinite,
  firebasePushId: isFirebasePushId,
  fullWidth: isFullWidth,
  function: _.isFunction,
  halfWidth: isHalfWidth,
  hash_crc32: (v) => isHash(v, 'crc32'),
  hash_crc32b: (v) => isHash(v, 'crc32b'),
  hash_md4: (v) => isHash(v, 'md4'),
  hash_md5: (v) => isHash(v, 'md5'),
  hash_ripemd128: (v) => isHash(v, 'ripemd128'),
  hash_ripemd160: (v) => isHash(v, 'ripemd160'),
  hash_sha1: (v) => isHash(v, 'sha1'),
  hash_sha256: (v) => isHash(v, 'sha256'),
  hash_sha384: (v) => isHash(v, 'sha384'),
  hash_sha512: (v) => isHash(v, 'sha512'),
  hash_tiger128: (v) => isHash(v, 'tiger128'),
  hash_tiger160: (v) => isHash(v, 'tiger160'),
  hash_tiger192: (v) => isHash(v, 'tiger192'),
  hexColor: isHexColor,
  hexadecimal: isHexadecimal,
  int: isInt,
  latLong: isLatLong,
  latitude: isLatitude,
  locale: isLocale,
  longitude: isLongitude,
  lowercase: isLowercase,
  magnetURI: isMagnetURI,
  map: _.isMap,
  militaryTime: isMilitaryTime,
  mimeType: isMimeType,
  mongoId: isMongoId,
  multibyte: isMultibyte,
  native: _.isNative,
  negative: isNegative,
  nil: _.isNil,
  null: _.isNull,
  number: isNumber,
  numberString: isNumberString,
  object: _.isObject,
  objectLike: _.isObjectLike,
  octal: isOctal,
  ok: z.isOk,
  plainObject: _.isPlainObject,
  port: isPort,
  positive: isPositive,
  primitive: z.isPrimitive,
  realObject: isRealObject,
  regExp: _.isRegExp,
  rgbColor: isRgbColor,
  safeInteger: _.isSafeInteger,
  semVer: isSemVer,
  set: _.isSet,
  single: z.isSingle,
  string: isString,
  surrogatePair: isSurrogatePair,
  symbol: _.isSymbol,
  timeZone: isTimeZone,
  true: z.isTrue,
  typedArray: _.isTypedArray,
  undefined: _.isUndefined,
  variableWidth: isVariableWidth,
  weakMap: _.isWeakMap,
  weakSet: _.isWeakSet,
} as any // @todo: why do we get this? src/code/OrAnd.ts(94,14): error TS2742: The inferred type of 'validZenTypesConformityValidators' cannot be named without a reference to '@neozen/zen/node_modules/type-fest'. This is likely not portable. A type annotation is necessary.

export type ValidZenValidator =
  | keyof typeof validZenTypesConformityValidators
  | PropertyDecorator
  | ValidZenValidator[] // recursive, means "and" and "or", alternatively!
  | ((value: any, validationArguments?: ValidationArguments) => boolean)
// | [string, (value: any, validationArguments?: ValidationArguments) => boolean] @todo: NOT Implemented

/**
 * [
 *   'undefined',
 *   ['number', [$Min(0), [$Max(100)], IsNumberHack(1984)],
 *   ['string', [$LengthMin(50), $BlahBlah()] ]
 * ]
 *
 * Returns `(undefined OR (number AND Min(0) AND (Max(100) OR IsNumberHack()) ) OR (string AND LengthMin(50) AND $BlahBlah()))`
 */
export const getValidatorsTypes = (validators: ValidZenValidator[], isOr?: boolean): string => {
  return validators
    .map((validator) => {
      if (_.isString(validator)) return validator

      if (_.isFunction(validator)) {
        return (validator as any).propertyDecoratorProducingFunctionName
          ? `$${(validator as any).propertyDecoratorProducingFunctionName}()`
          : `${validator.name || 'anonymous'}()`
      }

      if (_.isArray(validator)) return `(${getValidatorsTypes(validator, !isOr)})`

      return 'unknown'
    })
    .join(isOr ? ` OR ` : ` AND `)
}

// @todo: what an irony for validation!
const validateValidators = (validators: ValidZenValidator[]) => {
  if (!_.isArray(validators))
    throw new TypeError(
      `@ValidZen: validators must be an array of strings or functions, got ${type(
        validators
      )} ${validators}`
    )

  for (const validator of validators) {
    if (_.isFunction(validator)) continue

    if (_.isArray(validator) && validateValidators(validator)) continue

    if (_.isString(validator)) {
      if (!_.isFunction(validZenTypesConformityValidators[validator])) {
        // eg validator should be an existing function name "isNumber"
        throw new TypeError(
          `ValidZen: Unknown base type validator name: "${validator}". Allowed types are ${_.keys(
            validZenTypesConformityValidators
          ).join(', ')}`
        )
      }
      continue
    }

    throw new TypeError(`ValidZen: Unknown validator type: ${typeof validator} ${internalNodeUtilInspect(
      validator
    )}. Allowed types are:
    - string: one of ${_.keys(validZenTypesConformityValidators).join(', ')}
    - function: a validator function (value, validationArguments) => boolean
    - array: [ ... nested ANDs and more nested ORs ... ]]`)
  }

  return true
}

const validateRecursive = (
  value: unknown,
  validationArguments: ValidationArguments,
  validators: ValidZenValidator[],
  isORinValidateRecursive: boolean
): [boolean, ValidZenValidationError[]] => {
  _log(
    `validateRecursive() ${isORinValidateRecursive ? ' OR ' : ' AND '}:  value =`,
    value,
    `validators =`,
    validators
  )

  let validationErrors: ValidZenValidationError[] = []

  // validators.[every | some], depending on if we are in OR or AND
  const isSomeOrEveryValidatorPassing = validators[isORinValidateRecursive ? 'some' : 'every'](
    (validator) => {
      _log(
        `${isORinValidateRecursive ? 'OR' : 'AND'}: validators.${
          isORinValidateRecursive ? 'some' : 'every'
        }(validator =`,
        validator
      )

      if (_.isString(validator)) {
        if (!validZenTypesConformityValidators[validator](value)) {
          // a plain Validator Function, validator has been checked before
          // not throwing with false, so just add the errors
          validationErrors.push({ constraints: { [validator]: 'wrong type / check failed' } })
          _log(`FAILED! string validator: '${validator}') - returned falsey for value`, value)

          return false // stop validators.[ some | every]
        }

        _log(`PASS! string validator: '${validator}' returned true for value`, value)
        return true // next validators.[ some | every]
      }

      // check its valid, recursively!
      if (_.isArray(validator)) {
        const [result, nestedValidZenValidationErrors] = validateRecursive(
          value,
          validationArguments,
          validator,
          !isORinValidateRecursive
        )

        validationErrors.push(...nestedValidZenValidationErrors)
        return result // next or stop validators.[ some | every ]
      }

      if (_.isFunction(validator)) {
        // A function might be either:
        // 1 Simple function (eg isNumber) or isArrayWithAllowedValues
        // OR 2 - Property Decorators are functions - WORKING via wrapValidateByPropertyDecorator
        // OR 3 - a class constructor, called with validate() - NOT IMPLEMENTED and not needed with ValidateNested() & discriminator
        let result: boolean | void

        try {
          result = validator(value, validationArguments as any)
          if (result === false) {
            // a plain Validator Function, no errors thrown, but it just returns false, so add the errors
            validationErrors.push({
              constraints: {
                [`${validator.name || 'anonymous'}()`]: 'failed / returned falsey',
              },
            })
            _log(`FAILED! _.isFunction(${validator.name}) - returned falsey`)
            return false // stop/next validators.[ some | every]
          }
        } catch (errors) {
          errors = errors instanceof Error ? [errors] : arrayize(errors)
          validationErrors = [...validationErrors, ...errors]
          _log(`FAILED! _.isFunction(${validator.name}) - thrown Collected errors`, errors)
          return false // stop/next validators.[ some | every]
        }

        _log(`PASS! _.isFunction(${validator.name}) validator, result`, result)
        return result
        // @ts-ignore @todo: solve src/code/OrAnd.ts(363,80): error TS2731: Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.
      } else throw new TypeError(`Unknown validator type: ${type(validator)} ${validator}`)
    }
  )

  return [
    isSomeOrEveryValidatorPassing,
    [
      {
        constraints: {
          OrAnd: getValidatorsTypes(validators, isORinValidateRecursive),
        },
        children: validationErrors.map((ve) =>
          _.omit(ve, ['value', 'target', 'property'])
        ) as any, // @todo: remove any
      },
    ],
  ]
}

const getErrorMessage = (validationArguments, validators, isOR) =>
  `Property '${validationArguments.property}' failed`

/**
 @param validators a list of validators, ending with an optional validationOptions object
 */
export const OrAnd = (
  // @todo(3 2 2): typing support all signature overloading variants to express: (...validatorsAndLastValidationOptions: ValidZenValidator, validationOptions?: ValidationOptionsWrapped) =>
  ...validators: (ValidZenValidator)[] // | ValidationOptionsWrapped
): PropertyDecorator => {
  const _log = getTinyLog(false, 'OrAnd()')
  _log('OrAnd(...validators =', validators)

  // Decide if we have validationOptions (it's the last -and only- object in args)
  // @todo: are these validationOptions even respected?
  //        Can they / do they make sense? How are they managed inside class-validator?
  let validationOptions: ValidationOptionsWrapped
  if (isRealObject(_.last(validators)))
    // @todo: validate its a ValidationOptionsWrapped!
    validationOptions = validators.pop() as ValidationOptionsWrapped

  const _validators = validators as ValidZenValidator[]

  validateValidators(_validators) // throws if wrong at init time

  const validate = (value: any, validationArguments: ValidationArguments): boolean => {
    const _log = getTinyLog(false, 'OrAnd.validate()')
    let result = false
    let validationErrors: ValidZenValidationError[] = []

    try {
      ;[result, validationErrors] = validateRecursive(
        value,
        validationArguments,
        _validators,
        true
      )
    } catch (error) {
      _log('validateRecursive thrown', error)
    }

    _log('RETURNED FINAL result = validateRecursive() == ', result)

    if (!result) {
      const finalValidationErrors = <ValidationError[]>[
        {
          value,
          target: validationArguments.object,
          constraints: {
            OrAnd: getErrorMessage(validationArguments, _validators, true),
          },
          property: validationArguments.property,
          children: validationErrors,
        },
      ]

      _log('throw finalValidationErrors', finalValidationErrors)
      // eslint-disable-next-line @typescript-eslint/no-throw-literal @todo(1 1 3): fix throwing, and just return ValidationError[]? See open issue https://github.com/typestack/class-validator/issues/495
      throw finalValidationErrors
    }

    return result
  }

  return ValidateByAsValidatorFunction(
    {
      name: 'OrAnd',
      // constraints: [],
      validator: {
        validate,
        defaultMessage(validationArguments?: ValidationArguments) {
          return getErrorMessage(validationArguments, _validators, true)
        },
      },
    },
    validationOptions
  ) as PropertyDecorator
}
;(OrAnd as any)._isEnabledValidZenValidateByAsValidatorFunction = true

export const $OrAnd = wrapPropertyDecoratorUsingValidateBy(OrAnd, {
  validationOptionsIndex: Infinity,
})
