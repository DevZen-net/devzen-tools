/* eslint-disable eslint-comments/disable-enable-pair,one-var */
import { isOk } from '@neozen/zendash'
import * as _ from 'lodash'
import * as _f from 'lodash/fp'
import * as prettierSync from '@prettier/sync'
import * as assert from 'node:assert'

// eslint-disable-next-line unicorn/prefer-module,@typescript-eslint/no-var-requires
require('string.prototype.replaceall').shim()

export const eachWithOnly = (arr: object[], iteratee: (item, onlyMode: boolean) => void) => {
  const onlyMode = _.some(arr, (item: any) => !!item.only)
  _.each(arr, (item) => iteratee(item, onlyMode))
}

export const delaySecs = async (secs = 1) => {
  const promise = new Promise((resolve) =>
    setTimeout(() => {
      resolve(secs)
    }, secs * 1000)
  )
  if (typeof jest !== 'undefined') await jest.advanceTimersByTimeAsync(secs * 1000)
  // jest.runAllTimers(); // not needed ;-)
  return promise
}

// Utils for docs generation from specs - code is not pretty, what it does is :-/

const trimArray = (arr: any[]): any[] =>
  arr.slice(
    _.findIndex(arr, (item: any) => !!item),
    _.findLastIndex(arr, (item: any) => !!item) + 1
  )
assert.deepEqual(trimArray([0, undefined, 1, 2, 3, null, '', 0]), [1, 2, 3])
assert.deepEqual(trimArray([undefined, 5, 6, 0, 7, null]), [5, 6, 0, 7])

export const trimEmptyLines = (text: string) => {
  if (!text) return ``

  const lines = text.split('\n')
  const trimedLines = lines.map(_f.trim)

  return lines
    .slice(
      _.findIndex(trimedLines, (line) => !!line),
      _.findLastIndex(trimedLines, (line) => !!line) + 1
    )
    .join('\n')
}

assert.equal(
  trimEmptyLines(`

some text

`),
  `some text`
)

/**
 * Trims all lines, both sides & removes all empty lines
 * @param str
 */
export const trimLines = (str: string) =>
  str
    .split('\n')
    .map(_.trim)
    .filter(isOk)
    .join('\n')

/**
 * Trims all lines at end & removes all empty lines
 * @param str
 */
export const trimEndLines = (str: string) =>
  str
    .split('\n')
    .map(_.trimEnd)
    .filter(isOk)
    .join('\n')

export const expectToThrow = (
  fn,
  expectedErrors,
  errorsTranformation: (str: string) => string = _.identity
) => {
  // @todo(3 2 2): support RegExp
  try {
    fn()
  } catch (error) {
    // expect(errorsTranformation(error.message)).toEqual(errorsTranformation(expectedErrors))
    expect(errorsTranformation(error.message)).toMatch(errorsTranformation(expectedErrors))
    return
  }

  throw new Error(`Expected to throw, but didn't`)
}

export const IMPORTANT_NOTE = `
____________________________________________________________________________________________
**IMPORTANT NOTE**: This file is generated from integration tests, so that **all examples** here started their lives as **executed and tested specs**.
____________________________________________________________________________________________
`

export const DO_NOT_EDIT_NOTICE = (filename) =>
  `
${IMPORTANT_NOTE}

**DO NOT EDIT THIS FILE** permanently, as it is generated by executing \`ts-node ${filename}\` on every \`npm run dev\` build.

Awesomely, it executes, even without Jest!

And instead of testing, it just generates 3 files:

 * the entirety of \`readme.md\`

 * 2 executables inside \`src/docs/generated\`,

    * one is actually a test suite using nodejs \`assert\`

    * the other is a plain executable .js, with docs & expected results as comments

So you can play with these examples easily!
____________________________________________________________________________________________
`

/**
 * Extract the body of a function
 *
 * see https://stackoverflow.com/questions/12227735/how-to-get-function-body-text-in-javascript
 *
 * @todo: support async & non async functions mixed
 * @todo: fix object {...} in body breaking it
 */
export const fnBody = (fn): string => {
  // https://stackoverflow.com/a/59205556/799502
  const body = fn.toString().replace(
    // /^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,
    /^\W*(function[^{]+{([\S\s]*)}|[^=]+=>[^{]*{([\S\s]*)}|[^=]+=>(.+))/i,
    '$2$3$4'
  )
  return _.startsWith(_.trim(body), 'return') ? `${_.trim(body).slice(7)}` : body
}

const pretty = (codeTxt: string, prettyOptions = {}, discardBefore = ''): string => {
  let text: string
  try {
    text = prettierSync.format(codeTxt, {
      semi: false,
      parser: 'typescript',
      printWidth: 110,
      singleQuote: true,
      trailingComma: 'es5',
      ...prettyOptions,
    })
  } catch (error) {
    // workaround cause jest silences errors inside `it()` statements!
    console.log('prettier error', error)
    console.error('prettier error', error)
    // eslint-disable-next-line unicorn/no-process-exit
    process.exit(1)
  }

  const discardIdx = text.indexOf(discardBefore)
  return discardIdx === -1 ? text : text.slice(discardIdx)
}

/**
 * Format a block as Docs, either to markdown OR comments if it is intended for code
 * @param asMarkdown output as markdown, inside a ```codeHere()```.
 *                   Otherwise, print as executable JS code
 */
export const getDocsBlock =
  (asMarkdown = true) =>
  (text = ''): string => {
    text = trimEmptyLines(text)
    if (!text) return ''

    return (
      `${asMarkdown ? '' : '\n// '}${text.split('\n').join(asMarkdown ? '\n' : '\n// ')}` + `\n`
    )
  }
/**
 * Format a block as code, either to pretty print as markdown OR executable code
 * @param asMarkdown output as markdown, inside a ```codeHere()```. Otherwise, print as executable JS code
 */
export const getCodeBlock =
  (asMarkdown = true) =>
  (text: string, prettyOptions: object | false = {}, discardBefore?: string): string => {
    text = trimEmptyLines(text)
    text = prettyOptions ? pretty(text, prettyOptions, discardBefore) : text

    return `${asMarkdown ? `\`\`\`ts\n${text}\`\`\`` : `${text}`}\n`
  }

export const joinAll = (...texts: string[]) => texts.join('\n')

// run jest .spec files, outside jest, to produce docs :-)
export const noJestRunner = (asMarkdown = true) => {
  if (typeof jest === 'undefined') {
    const JEST = 'jest'
    // @ts-ignore
    global[JEST] = new Proxy(
      {},
      {
        get: () => _.noop,
      }
    )
  }

  if (typeof describe === 'undefined') {
    const DESCRIBE = 'describe'

    const describeFn = (name, describeBody) => {
      console.log(name)
      describeBody()
    }

    type TCase = string[]
    ;(describeFn as any).each = (casesTable: TCase[]) => (name, eachBody) => {
      console.log(name)
      _.each(casesTable, (caseArgs) => eachBody(...caseArgs))
    }
    ;(describeFn as any).only = describeFn // ie ignore .only
    ;(describeFn as any).skip = _.noop

    // @ts-ignore
    global[DESCRIBE] = describeFn
  }

  if (typeof it == 'undefined') {
    const IT = 'it'
    const itFn = (descr, itBody) => console.log(descr)
    ;(itFn as any).only = itFn // ie ignore .only
    ;(itFn as any).skip = _.noop
    // @ts-ignore
    global[IT] = itFn
  }

  if (typeof beforeEach == 'undefined') {
    const BEFORE_EACH = 'beforeEach'
    global[BEFORE_EACH] = _.noop
  }

  if (typeof beforeAll == 'undefined') {
    const BEFORE_ALL = 'beforeAll'
    global[BEFORE_ALL] = _.noop
  }

  if (typeof afterEach == 'undefined') {
    const AFTER_EACH = 'afterEach'
    global[AFTER_EACH] = _.noop
  }

  if (typeof afterAll == 'undefined') {
    const AFTER_ALL = 'afterEach'
    global[AFTER_ALL] = _.noop
  }
}
